---
title: Plaintext Sequence Numbers for Datagram Transport Security Layer 1.3
abbrev: Plaintext Sequence Numbers for DTLS1.3
docname: draft-pismenny-tls-dtls-plaintext-sequence-number-latest
submissiontype: IETF
category: std

ipr: trust200902
area: Security
workgroup: TLS Working Group

stand_alone: yes
pi: [toc, sortrefs, symrefs]

keyword: Internet-Draft
author:
 -
    fullname: Boris Pismenny
    organization: NVIDIA
    email: boris.pismenny@gmail.com

normative:
  RFC9147:

informative:


--- abstract

This document specifies a TLS 1.3 extension that enables DTLS 1.3 to negotiate
the use of plaintext sequence numbers instead of protected sequence numbers.
Plaintext sequence numbers are advantageous in closed networks where the
benefits of lower latency outweigh the risk of ossification and reduced
privacy.

--- middle

# Introduction

Datagram Transport Layer Security (DTLS) 1.3 [RFC9147] packet encryption
protects not only record data, but also the record header's sequence number.
The sequence number is encrypted by XORing it with a mask which is generated by encrypting
the leading 16 bytes of the record's ciphertext with a sequence number key.

For high performance networking, sequence number encryption is a trade-off between
ossification and privacy on the one hand and latency and complexity for
hardware acceleration on the other hand. Sequence number encryption improves privacy by
hiding the real ordering of packets from on-path observers. Sequence number encryption also
prevents protocol ossification, when middleboxes manipulate packet delivery
based on the sequence number.  Sequence number encryption however adds latency to packet processing on
both sender and receiver. Sequence number encryption also increases the complexity and cost
of NIC encryption accelerators, which are crucial for enabling encryption in
high performance computing systems that seek to maximize performance and lowest
penalty possible for encryption.

# Conventions and Definitions

{::boilerplate bcp14-tagged}

# Sequence Number Encryption Extension

~~~~
enum {
  default_cipher (0),
  plaintext (1),
  (65536)
} SeqNumEncAlgs;

struct {
  select (Handshake.msg_type) {
    case CH:
      SeqNumEncAlgs supported_algs<1..255>;

    case SH:
      SeqNumEncAlgs selected_alg;
  };
} SupportedSequenceNumberEncryptionAlgorithms;
~~~~

[comment]: > OPEN: This extension might fit nicely with the TLS flags extension
[comment]: > {{!I-D.draft-ietf-tls-tlsflags}}, but TLS flags doesn't seem to apply to
[comment]: > DTLS.

The "sequence_number_encryption_algorithms" extension is used by the client
to specify the record sequence number encryption algorithms it supports
and by the server to select the algorithm it prefers. The ClientHello message
lists algorithms by the order of their preference, starting from the most
preferred algorithm.

If this extension is not present, in either ClientHello or
EncryptedExtensions, then both parties MUST fallback to the
default record sequence number encryption algorithm.

# Security Considerations

This document allows endpoints to disable the record sequence number encryption
algorithm, which retracts the on-path tracking anti-ossification protection
established in [RFC9147] record sequence number encryption. It is therefore
RECOMMENDED that users limit the deployment of this extension to closed
environments, such as data centers, where the risk of on-path observers is
negligible.

# IANA Considerations

IANA is requested to assign a new value from the TLS ExtensionType values registry:

* The Extension Name should be sequence_number_encryption_algorithms
* The TLS 1.3 value should be CH,HRR,SH
* The DTLS-Only value should be Y
* The Recommended value should be N
* The Reference should be this document

--- back

# Acknowledgments
{:numbered="false"}

TODO acknowledge.

